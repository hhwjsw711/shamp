/**
 * Ticket mutations - Internal mutations for ticket data modification
 */

import { internalMutation, mutation } from "../../_generated/server";
import { v } from "convex/values";
import type { Id } from "../../_generated/dataModel";
import { validateUserId } from "../../utils/queryAuth";
import { internal } from "../../_generated/api";

/**
 * Create ticket (internal)
 * Used by handlers and actions that already have auth context
 */
export const createInternal = internalMutation({
  args: {
    createdBy: v.id("users"),
    name: v.optional(v.string()), // Ticket creator name (optional, can get from user if authenticated)
    description: v.string(),
    location: v.optional(v.string()),
    photoIds: v.array(v.id("_storage")), // Required array of photo IDs (max 5)
    issueType: v.optional(v.string()),
    predictedTags: v.optional(v.array(v.string())),
    urgency: v.optional(
      v.union(
        v.literal("emergency"),
        v.literal("urgent"),
        v.literal("normal"),
        v.literal("low")
      )
    ),
    status: v.optional(
      v.union(
        v.literal("analyzing"),
        v.literal("analyzed"),
        v.literal("reviewed"),
        v.literal("processing"),
        v.literal("quotes_available"),
        v.literal("quote_selected"),
        v.literal("fixed"),
        v.literal("closed")
      )
    ),
    // PIN submission fields
    submittedViaPin: v.optional(v.boolean()),
    pinOwnerId: v.optional(v.id("users")),
    submittedByEmail: v.optional(v.string()),
    submittedByPhone: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<Id<"tickets">> => {
    // Validate photoIds array length (max 5)
    if (args.photoIds.length === 0) {
      throw new Error("At least one photo is required");
    }
    if (args.photoIds.length > 5) {
      throw new Error("Maximum 5 photos allowed");
    }

    const ticketId = await ctx.db.insert("tickets", {
      createdBy: args.createdBy,
      name: args.name,
      description: args.description,
      location: args.location,
      photoIds: args.photoIds,
      beforePhotoIds: args.photoIds, // Set beforePhotoIds to initial photos
      issueType: args.issueType,
      predictedTags: args.predictedTags || [],
      urgency: args.urgency,
      status: args.status || "analyzing",
      vendorStatus: "not_started", // Initialize vendor status
      createdAt: Date.now(),
      submittedViaPin: args.submittedViaPin || false,
      pinOwnerId: args.pinOwnerId,
      submittedByEmail: args.submittedByEmail,
      submittedByPhone: args.submittedByPhone,
    });

    return ticketId;
  },
});

/**
 * Update ticket fields (internal)
 * Used by actions and handlers that already have auth context
 */
export const updateInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    ticketName: v.optional(v.string()), // Concise name for the ticket (generated by AI analysis)
    issueType: v.optional(v.string()),
    predictedTags: v.optional(v.array(v.string())),
    problemDescription: v.optional(v.string()), // Detailed problem description in simple terms
    description: v.optional(v.string()),
    location: v.optional(v.string()),
    name: v.optional(v.string()),
    photoIds: v.optional(v.array(v.id("_storage"))),
    firecrawlResultsId: v.optional(v.id("firecrawlResults")),
    selectedVendorId: v.optional(v.id("vendors")),
    selectedVendorQuoteId: v.optional(v.id("vendorQuotes")),
    conversationId: v.optional(v.id("conversations")),
    scheduledDate: v.optional(v.number()),
    verificationPhotoId: v.optional(v.id("_storage")),
    closedAt: v.optional(v.number()),
    embedding: v.optional(v.array(v.float64())),
    // PIN submission fields
    submittedViaPin: v.optional(v.boolean()), // Whether ticket was submitted via PIN
    pinOwnerId: v.optional(v.id("users")), // Which user's PIN was used
    submittedByEmail: v.optional(v.string()), // Email of PIN submitter (optional)
    submittedByPhone: v.optional(v.string()), // Phone of PIN submitter (optional)
    quoteStatus: v.optional(
      v.union(
        v.literal("awaiting_quotes"),
        v.literal("quotes_received"),
        v.literal("quotes_available"),
        v.literal("scheduling")
      )
    ),
    status: v.optional(
      v.union(
        v.literal("analyzing"),
        v.literal("analyzed"),
        v.literal("reviewed"),
        v.literal("processing"),
        v.literal("quotes_available"),
        v.literal("quote_selected"),
        v.literal("fixed"),
        v.literal("closed")
      )
    ),
    // Urgency/Priority
    urgency: v.optional(
      v.union(
        v.literal("emergency"),
        v.literal("urgent"),
        v.literal("normal"),
        v.literal("low")
      )
    ),
    // Real-Time Vendor Status
    vendorStatus: v.optional(
      v.union(
        v.literal("not_started"),
        v.literal("arrived"),
        v.literal("in_progress"),
        v.literal("completed")
      )
    ),
    vendorArrivedAt: v.optional(v.number()),
    vendorStartedAt: v.optional(v.number()),
    vendorCompletedAt: v.optional(v.number()),
    // Before/After Photos
    beforePhotoIds: v.optional(v.array(v.id("_storage"))),
    afterPhotoIds: v.optional(v.array(v.id("_storage"))),
    // Guest Impact Tracking
    affectedRooms: v.optional(v.array(v.string())),
    guestsAffected: v.optional(v.number()),
    guestsNotified: v.optional(v.boolean()),
    guestNotificationMethod: v.optional(
      v.union(
        v.literal("email"),
        v.literal("sms"),
        v.literal("phone"),
        v.literal("in_person"),
        v.literal("none")
      )
    ),
    guestNotificationSentAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { ticketId, ...updates } = args;
    
    // Only update fields that are provided
    const fieldsToUpdate: Record<string, any> = {};
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== undefined) {
        fieldsToUpdate[key] = value;
      }
    });

    if (Object.keys(fieldsToUpdate).length === 0) {
      return; // No updates to make
    }

    await ctx.db.patch(ticketId, fieldsToUpdate);
  },
});

/**
 * Update ticket status (internal)
 */
export const updateStatusInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    status: v.union(
      v.literal("analyzing"),
      v.literal("analyzed"),
      v.literal("reviewed"),
      v.literal("processing"),
      v.literal("quotes_available"),
      v.literal("fixed"),
      v.literal("closed")
    ),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.ticketId, {
      status: args.status,
    });
  },
});

/**
 * Assign vendor to ticket (internal)
 */
export const assignVendorInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    vendorId: v.id("vendors"),
    quoteId: v.id("vendorQuotes"),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.ticketId, {
      selectedVendorId: args.vendorId,
      selectedVendorQuoteId: args.quoteId,
      status: "quote_selected",
    });
  },
});

/**
 * Close ticket (internal)
 */
export const closeTicketInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.ticketId, {
      status: "closed",
      closedAt: Date.now(),
    });
  },
});

/**
 * Update vendor status (internal)
 */
export const updateVendorStatusInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    vendorStatus: v.union(
      v.literal("not_started"),
      v.literal("arrived"),
      v.literal("in_progress"),
      v.literal("completed")
    ),
    vendorArrivedAt: v.optional(v.number()),
    vendorStartedAt: v.optional(v.number()),
    vendorCompletedAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { ticketId, vendorStatus, vendorArrivedAt, vendorStartedAt, vendorCompletedAt } = args;
    
    const updates: Record<string, any> = {
      vendorStatus,
    };
    
    if (vendorArrivedAt !== undefined) {
      updates.vendorArrivedAt = vendorArrivedAt;
    }
    if (vendorStartedAt !== undefined) {
      updates.vendorStartedAt = vendorStartedAt;
    }
    if (vendorCompletedAt !== undefined) {
      updates.vendorCompletedAt = vendorCompletedAt;
    }
    
    await ctx.db.patch(ticketId, updates);
  },
});

/**
 * Add after photos to ticket (internal)
 */
export const addAfterPhotosInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    afterPhotoIds: v.array(v.id("_storage")),
  },
  handler: async (ctx, args) => {
    const ticket = await ctx.db.get(args.ticketId);
    if (!ticket) {
      throw new Error("Ticket not found");
    }
    
    const existingAfterPhotoIds = ticket.afterPhotoIds || [];
    const updatedAfterPhotoIds = [...existingAfterPhotoIds, ...args.afterPhotoIds];
    
    await ctx.db.patch(args.ticketId, {
      afterPhotoIds: updatedAfterPhotoIds,
    });
  },
});

/**
 * Update guest impact tracking (internal)
 */
export const updateGuestImpactInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
    affectedRooms: v.optional(v.array(v.string())),
    guestsAffected: v.optional(v.number()),
    guestsNotified: v.optional(v.boolean()),
    guestNotificationMethod: v.optional(
      v.union(
        v.literal("email"),
        v.literal("sms"),
        v.literal("phone"),
        v.literal("in_person"),
        v.literal("none")
      )
    ),
    guestNotificationSentAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { ticketId, ...updates } = args;
    
    const fieldsToUpdate: Record<string, any> = {};
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== undefined) {
        fieldsToUpdate[key] = value;
      }
    });

    if (Object.keys(fieldsToUpdate).length === 0) {
      return; // No updates to make
    }

    await ctx.db.patch(ticketId, fieldsToUpdate);
  },
});

/**
 * Delete ticket (public mutation)
 * Only allows deletion of tickets in early stages or fixed/closed
 */
export const deleteTicket = mutation({
  args: {
    ticketId: v.id("tickets"),
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // Get ticket
    const ticket = await ctx.db.get(args.ticketId);
    
    if (!ticket) {
      throw new Error("Ticket not found");
    }
    
    // SECURITY: Ensure ticket belongs to the requesting user
    if (ticket.createdBy !== args.userId) {
      throw new Error("Unauthorized: Ticket does not belong to user");
    }
    
    // Check if ticket can be deleted
    // Can delete: analyzed, reviewed OR fixed/closed
    // Cannot delete: processing, quotes_available, quote_selected (vendor engagement stages)
    const deletableStatuses = [
      "analyzed",
      "reviewed",
      "fixed",
      "closed",
    ];
    
    if (!deletableStatuses.includes(ticket.status)) {
      throw new Error(
        `Ticket cannot be deleted. Current status: ${ticket.status}. Cannot delete tickets with vendor engagement (processing, quotes_available, quote_selected).`
      );
    }
    
    // Call internal mutation to delete ticket (handles file deletion)
    await ctx.runMutation(internal.functions.tickets.mutations.deleteTicketInternal, {
      ticketId: args.ticketId,
    });
    
    return { success: true };
  },
});

/**
 * Delete ticket (internal mutation)
 * Handles actual deletion and file cleanup
 */
export const deleteTicketInternal = internalMutation({
  args: {
    ticketId: v.id("tickets"),
  },
  handler: async (ctx, args) => {
    const ticket = await ctx.db.get(args.ticketId);
    
    if (!ticket) {
      throw new Error("Ticket not found");
    }
    
    // Delete all photos from storage
    const allPhotoIds = [
      ...(ticket.photoIds || []),
      ...(ticket.beforePhotoIds || []),
      ...(ticket.afterPhotoIds || []),
    ];
    
    for (const photoId of allPhotoIds) {
      try {
        await ctx.storage.delete(photoId);
      } catch (error) {
        // Log error but don't fail if file deletion fails
        console.error(`Failed to delete photo ${photoId} from storage:`, error);
      }
    }
    
    // Delete ticket from database
    await ctx.db.delete(args.ticketId);
  },
});

/**
 * Delete photo from ticket (public mutation)
 */
export const deletePhoto = mutation({
  args: {
    ticketId: v.id("tickets"),
    photoId: v.id("_storage"),
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // Get ticket
    const ticket = await ctx.db.get(args.ticketId);
    
    if (!ticket) {
      throw new Error("Ticket not found");
    }
    
    // SECURITY: Ensure ticket belongs to the requesting user
    if (ticket.createdBy !== args.userId) {
      throw new Error("Unauthorized: Ticket does not belong to user");
    }
    
    // Check if photoId exists in ticket's photoIds
    if (!ticket.photoIds.includes(args.photoId)) {
      throw new Error("Photo not found in ticket");
    }
    
    // Remove photoId from ticket
    const updatedPhotoIds = ticket.photoIds.filter((id) => id !== args.photoId);
    await ctx.db.patch(args.ticketId, {
      photoIds: updatedPhotoIds,
    });

    // Delete file from storage
    try {
      await ctx.storage.delete(args.photoId);
    } catch (error) {
      // Log error but don't fail if file deletion fails
      console.error(`Failed to delete photo ${args.photoId} from storage:`, error);
    }
  },
});

/**
 * Mark ticket as reviewed (public mutation)
 * Allows users to mark their ticket as reviewed after analysis
 */
export const markAsReviewed = mutation({
  args: {
    ticketId: v.id("tickets"),
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    // Validate userId exists
    await validateUserId(ctx, args.userId);
    
    // Get ticket to verify ownership
    const ticket = await ctx.db.get(args.ticketId);
    if (!ticket) {
      throw new Error("Ticket not found");
    }
    
    if (ticket.createdBy !== args.userId) {
      throw new Error("Not authorized to update this ticket");
    }
    
    // Only allow marking as reviewed if ticket is currently "analyzed"
    if (ticket.status !== "analyzed") {
      throw new Error(`Cannot mark ticket as reviewed. Current status is: ${ticket.status}`);
    }
    
    // Update status to reviewed
    await ctx.db.patch(args.ticketId, {
      status: "reviewed",
    });
    
    return { success: true };
  },
});
