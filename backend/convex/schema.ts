import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Users table for custom authentication (email/password, Google OAuth, pin)
  users: defineTable({
    email: v.string(),
    name: v.optional(v.string()),
    orgName: v.optional(v.string()),
    location: v.optional(v.string()),
    profilePic: v.optional(v.string()), // URL to profile picture
    googleId: v.optional(v.string()), // Google OAuth ID
    hashedPassword: v.optional(v.string()), // Hashed password for email/password auth
    pin: v.optional(v.string()), // Hashed pin for staff/guest auth
    pinCreatedAt: v.optional(v.number()), // When PIN was created/regenerated
    pinEnabled: v.optional(v.boolean()), // Whether PIN sharing is enabled
    emailVerified: v.optional(v.boolean()),
    createdAt: v.number(),
    lastLoginAt: v.optional(v.number()),
    onboardingCompleted: v.optional(v.boolean()),
  })
    .index("by_email", ["email"])
    .index("by_googleId", ["googleId"]),

  // Sessions table for cookie-based auth
  sessions: defineTable({
    userId: v.id("users"),
    sessionToken: v.string(), // JWT token stored in cookie
    expiresAt: v.number(),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
    createdAt: v.number(),
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_userId", ["userId"])
    .index("by_expiresAt", ["expiresAt"]),

  // Email verification codes table
  emailVerificationCodes: defineTable({
    userId: v.id("users"),
    email: v.string(),
    code: v.string(), // 6-digit code
    expiresAt: v.number(),
    verified: v.optional(v.boolean()),
    createdAt: v.number(),
  })
    .index("by_userId", ["userId"])
    .index("by_email", ["email"])
    .index("by_code", ["code"]),

  // Password reset codes table
  passwordResetCodes: defineTable({
    userId: v.id("users"),
    email: v.string(),
    code: v.string(), // 6-digit code
    expiresAt: v.number(),
    used: v.optional(v.boolean()),
    createdAt: v.number(),
  })
    .index("by_userId", ["userId"])
    .index("by_email", ["email"])
    .index("by_code", ["code"]),

  // PIN sessions table for temporary tokens (PIN-based ticket submission)
  pinSessions: defineTable({
    pinOwnerId: v.id("users"), // User whose PIN was used
    sessionToken: v.string(), // Temporary JWT token
    expiresAt: v.number(),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
    createdAt: v.number(),
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_pinOwnerId", ["pinOwnerId"])
    .index("by_expiresAt", ["expiresAt"]),

  // Tickets table
  tickets: defineTable({
    createdBy: v.id("users"),
    name: v.optional(v.string()), // Ticket creator name (optional, can get from user if authenticated)
    ticketName: v.optional(v.string()), // Concise name for the ticket (generated by AI analysis)
    issueType: v.optional(v.string()),
    predictedTags: v.array(v.string()),
    problemDescription: v.optional(v.string()), // Detailed problem description in simple terms (generated by AI analysis)
    description: v.string(),
    location: v.optional(v.string()),
    photoIds: v.array(v.id("_storage")), // Required array of photo IDs (max 5) - initial/before photos
    createdAt: v.number(),
    status: v.union(
      v.literal("analyzing"),
      v.literal("analyzed"),
      v.literal("reviewed"),
      v.literal("processing"),
      v.literal("quotes_available"),
      v.literal("scheduled"),
      v.literal("fixed"),
      v.literal("closed")
    ),
    // Urgency/Priority Classification
    urgency: v.optional(
      v.union(
        v.literal("emergency"), // Critical: fire, flood, security, guest safety
        v.literal("urgent"), // High: guest-facing issues, operational disruption
        v.literal("normal"), // Standard: routine maintenance
        v.literal("low") // Low: non-critical, cosmetic issues
      )
    ),
    // Real-Time Vendor Status Tracking
    vendorStatus: v.optional(
      v.union(
        v.literal("not_started"), // Vendor not yet on-site
        v.literal("arrived"), // Vendor has arrived at location
        v.literal("in_progress"), // Vendor is actively working
        v.literal("completed") // Vendor has completed work (before verification)
      )
    ),
    vendorArrivedAt: v.optional(v.number()), // Timestamp when vendor arrived
    vendorStartedAt: v.optional(v.number()), // Timestamp when vendor started work
    vendorCompletedAt: v.optional(v.number()), // Timestamp when vendor completed work
    // Before/After Photo Documentation
    beforePhotoIds: v.optional(v.array(v.id("_storage"))), // Photos taken when issue reported (same as photoIds initially)
    afterPhotoIds: v.optional(v.array(v.id("_storage"))), // Photos taken after vendor completes work
    // Guest Impact Tracking
    affectedRooms: v.optional(v.array(v.string())), // Room numbers or areas affected (e.g., ["205", "206", "Lobby"])
    guestsAffected: v.optional(v.number()), // Number of guests affected
    guestsNotified: v.optional(v.boolean()), // Whether guests have been notified
    guestNotificationMethod: v.optional(
      v.union(
        v.literal("email"),
        v.literal("sms"),
        v.literal("phone"),
        v.literal("in_person"),
        v.literal("none")
      )
    ),
    guestNotificationSentAt: v.optional(v.number()), // When guests were notified
    firecrawlResultsId: v.optional(v.id("firecrawlResults")),
    selectedVendorId: v.optional(v.id("vendors")),
    selectedVendorQuoteId: v.optional(v.id("vendorQuotes")),
    conversationId: v.optional(v.id("conversations")),
    scheduledDate: v.optional(v.number()),
    verificationPhotoId: v.optional(v.id("_storage")),
    closedAt: v.optional(v.number()),
    embedding: v.optional(v.array(v.float64())),
    // PIN submission fields
    submittedViaPin: v.optional(v.boolean()), // Whether ticket was submitted via PIN
    pinOwnerId: v.optional(v.id("users")), // Which user's PIN was used
    submittedByEmail: v.optional(v.string()), // Email of PIN submitter (optional)
    submittedByPhone: v.optional(v.string()), // Phone of PIN submitter (optional)
    quoteStatus: v.optional(
      v.union(
        v.literal("awaiting_quotes"),
        v.literal("quotes_received"),
        v.literal("quotes_available"),
        v.literal("scheduling")
      )
    ),
  })
    .index("by_createdBy", ["createdBy"])
    .index("by_status", ["status"])
    .index("by_selectedVendorId", ["selectedVendorId"])
    .index("by_quoteStatus", ["quoteStatus"])
    .index("by_pinOwnerId", ["pinOwnerId"])
    .index("by_submittedViaPin", ["submittedViaPin"])
    .index("by_urgency", ["urgency"])
    .index("by_vendorStatus", ["vendorStatus"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1536,
      filterFields: ["status", "issueType"],
    }),

  // Vendors table
  vendors: defineTable({
    businessName: v.string(),
    email: v.string(),
    phone: v.optional(v.string()),
    specialty: v.string(),
    address: v.string(),
    rating: v.optional(v.number()),
    emailStatus: v.optional(
      v.union(
        v.literal("valid"),
        v.literal("invalid"),
        v.literal("bounced"),
        v.literal("complained"),
        v.literal("doNotEmail")
      )
    ),
    lastEmailError: v.optional(v.string()),
    jobs: v.array(
      v.object({
        ticketId: v.id("tickets"),
        assignedAt: v.number(),
        completedAt: v.optional(v.number()),
        feedback: v.optional(v.string()),
      })
    ),
    embedding: v.optional(v.array(v.float64())),
  })
    .index("by_email", ["email"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1536,
      filterFields: ["specialty"],
    }),

  // Email mappings for tracking Resend emails
  emailMappings: defineTable({
    emailId: v.string(), // Resend email ID
    ticketId: v.id("tickets"),
    vendorId: v.id("vendors"),
    sentAt: v.number(),
    status: v.optional(
      v.union(
        v.literal("sent"),
        v.literal("delivered"),
        v.literal("bounced"),
        v.literal("complained"),
        v.literal("opened"),
        v.literal("clicked")
      )
    ),
    lastEventAt: v.optional(v.number()),
    bounceReason: v.optional(v.string()),
  })
    .index("by_emailId", ["emailId"])
    .index("by_ticketId", ["ticketId"])
    .index("by_vendorId", ["vendorId"]),

  // Firecrawl results for vendor discovery
  firecrawlResults: defineTable({
    ticketId: v.id("tickets"),
    results: v.array(
      v.object({
        businessName: v.string(),
        email: v.optional(v.string()),
        phone: v.optional(v.string()),
        specialty: v.string(),
        address: v.string(),
        rating: v.optional(v.number()),
        vendorId: v.optional(v.id("vendors")), // Optional vendor ID if vendor exists in database
      })
    ),
    createdAt: v.number(),
  }).index("by_ticketId", ["ticketId"]),

  // Conversations table for ticket messaging
  conversations: defineTable({
    ticketId: v.id("tickets"),
    messages: v.array(
      v.object({
        sender: v.union(
          v.literal("user"),
          v.literal("agent"),
          v.literal("vendor")
        ),
        message: v.string(),
        date: v.number(),
      })
    ),
    createdAt: v.number(),
    updatedAt: v.number(),
    embedding: v.optional(v.array(v.float64())),
  })
    .index("by_ticketId", ["ticketId"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1536,
      filterFields: ["ticketId"],
    }),

  // Vendor outreach tracking
  vendorOutreach: defineTable({
    ticketId: v.id("tickets"),
    vendorId: v.id("vendors"),
    emailId: v.string(), // Resend email ID
    emailSentAt: v.number(),
    status: v.union(
      v.literal("sent"),
      v.literal("delivered"),
      v.literal("opened"),
      v.literal("responded"),
      v.literal("bounced"),
      v.literal("expired")
    ),
    followUpSentAt: v.optional(v.number()),
    expiresAt: v.number(), // Quote request expiration time
    embedding: v.optional(v.array(v.float64())),
  })
    .index("by_ticketId", ["ticketId"])
    .index("by_vendorId", ["vendorId"])
    .index("by_emailId", ["emailId"])
    .index("by_status", ["status"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1536,
      filterFields: ["ticketId", "vendorId", "status"],
    }),

  // Vendor quotes
  vendorQuotes: defineTable({
    ticketId: v.id("tickets"),
    vendorId: v.id("vendors"),
    vendorOutreachId: v.id("vendorOutreach"),
    price: v.number(), // Price in cents or smallest currency unit
    currency: v.string(), // Currency code (USD, EUR, etc.)
    estimatedDeliveryTime: v.number(), // Estimated time in hours
    ratings: v.optional(v.number()), // Vendor-provided rating/review score
    responseText: v.string(), // Raw email response from vendor
    quoteDocumentId: v.optional(v.id("_storage")), // Stored quote document (PDF, image, etc.)
    quoteDocumentType: v.optional(v.string()), // Document type (pdf, image, etc.)
    scheduledDate: v.optional(v.number()), // When vendor can come to fix the issue (timestamp in milliseconds)
    fixDuration: v.optional(v.number()), // How long the fix will take (in hours)
    status: v.union(
      v.literal("pending"),
      v.literal("received"),
      v.literal("selected"),
      v.literal("rejected"),
      v.literal("expired")
    ),
    responseReceivedAt: v.optional(v.number()),
    createdAt: v.number(),
    score: v.optional(v.number()), // Calculated ranking score
    embedding: v.optional(v.array(v.float64())),
  })
    .index("by_ticketId", ["ticketId"])
    .index("by_vendorId", ["vendorId"])
    .index("by_status", ["status"])
    .index("by_ticketId_status", ["ticketId", "status"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1536,
      filterFields: ["ticketId", "vendorId", "status"],
    }),

  // Escalations table for vendor emails that need user attention
  escalations: defineTable({
    ticketId: v.id("tickets"),
    vendorId: v.id("vendors"),
    vendorOutreachId: v.id("vendorOutreach"),
    conversationId: v.id("conversations"),
    userId: v.id("users"), // User who needs to review
    vendorMessage: v.string(), // The vendor message that triggered escalation
    vendorEmail: v.string(),
    intent: v.union(
      v.literal("question"),
      v.literal("clarification"),
      v.literal("quote_provided"),
      v.literal("declining"),
      v.literal("follow_up"),
      v.literal("complex"),
      v.literal("other")
    ),
    confidenceScore: v.number(), // Agent confidence score (0-1)
    reason: v.string(), // Why this was escalated
    status: v.union(
      v.literal("pending"), // Awaiting user review
      v.literal("reviewed"), // User has reviewed
      v.literal("responded"), // User has responded
      v.literal("resolved") // Escalation resolved
    ),
    agentSuggestedResponse: v.optional(v.string()), // Agent's suggested response (if any)
    userResponse: v.optional(v.string()), // User's actual response
    resolvedAt: v.optional(v.number()),
    createdAt: v.number(),
  })
    .index("by_ticketId", ["ticketId"])
    .index("by_userId", ["userId"])
    .index("by_status", ["status"])
    .index("by_userId_status", ["userId", "status"]),
});

